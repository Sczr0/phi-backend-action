name: Unpack APK and Distribute Files

# 触发器配置：
# 1. 允许手动触发，方便我们测试
# 2. 允许被Worker通过API调用触发
on:
  workflow_dispatch:
    inputs:
      apk_url:
        description: '输入要测试的APK下载链接'
        required: true
  
  repository_dispatch:
    types: [new_phigros_version]

permissions:
  contents: write # 允许对仓库内容（代码）进行写操作

jobs:
  unpack-and-distribute:
    runs-on: ubuntu-latest
    steps:
      # 1. 下载当前仓库的代码（包含所有python脚本和依赖）
      - name: Checkout Main Repo
        uses: actions/checkout@v4

      # 2. 安装系统依赖 (用于音频解码)
      - name: Install System Dependencies (Ogg & Vorbis)
        run: |
          sudo apt-get update
          sudo apt-get install -y libvorbis-dev libogg-dev

      # 3. 设置Python环境
      - name: Set up Python 3.9
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      # 4. 安装Python库
      - name: Install Python Dependencies
        run: |
          python -m pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      # 5. 运行我们的主脚本，生成所有文件
      - name: Run Main Orchestrator Script
        env:
          APK_DOWNLOAD_URL: ${{ github.event.inputs.apk_url || github.event.client_payload.download_url }}
        run: |
          python main.py
      
      # -------------------------------------------------------------
      # ▼▼▼ 以下是新增的文件分发逻辑 ▼▼▼
      # -------------------------------------------------------------

      # 6. 配置Git，让它知道提交者是谁
      - name: Configure Git
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'

      - name: Commit Artifacts to This Repository
        run: |
          echo "Cleaning up old artifacts and staging new ones..."
          # 清理旧的 output 文件夹，确保一个干净的开始
          rm -rf output
          # 创建一个统一的输出文件夹，防止根目录混乱
          mkdir -p output

          # 将所有生成的文件夹移动到 output 文件夹内
          # 如果文件夹不存在，`mv` 会报错，所以我们先判断一下
          [ -d "info" ] && mv info/ ./output/
          [ -d "illustration" ] && mv illustration/ ./output/
          [ -d "illustrationBlur" ] && mv illustrationBlur/ ./output/
          [ -d "illustrationLowRes" ] && mv illustrationLowRes/ ./output/
          [ -d "avatar" ] && mv avatar/ ./output/
          [ -d "music" ] && mv music/ ./output/
          [ -d "chart" ] && mv chart/ ./output/
          
          # 将 output 文件夹添加到 Git 暂存区
          git add output/

          # 检查是否有文件变动（staged），只有在有变动时才提交
          if ! git diff --staged --quiet; then
            echo "Changes detected in artifacts, committing to this repo..."
            git commit -m "chore(artifacts): 自动归档产物 (版本 ${{ github.event.client_payload.version_name || 'MANUAL' }})"
            # 推送回当前分支。GITHUB_TOKEN 是由 GitHub Actions 自动提供的，有权限推送到本仓库
            git push
          else
            echo "No new artifacts generated, skipping commit to this repo."
          fi